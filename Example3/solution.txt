1. Open at least two memory dumps in Visual Studio. Use Parallel Stacks window to determine what code threads are executing.




















1.1. Two threads are inside IsRelated().




















2. Examine the methods IsRelated() (notice comments there) and GetCompulationallyExpensiveCalculationResult() to determine what might be happening. Select stack frames of these methods and look at local variables.




















2.1. GetCompulationallyExpensiveCalculationResult() has variable p value 0 in one thread and 97 in the other. In both threads remainingItems has all 100 items (it was initialized with 100 items). At first glance it looked like threads have been stuck inside IsRelated(), however examination revealed that GetCompulationallyExpensiveCalculationResult() has a "potentially infinite" loop.




















3. Assuming IsRelated() is a "black box", it is needed to determine whether threads have stuck inside IsRelated() or IsRelated() is called from infinite loop inside GetCompulationallyExpensiveCalculationResult().




















3.1. Examining heap addresses of local variables in WinDbg can be used for this (however is not 100% reliable!). The same object will usually have the same address on heap. If local variable ts inside IsRelated() will be pointing to a different address (comparing the same thread in several dump files that are taken from the same process, but in different moments of time) most likely the method has returned and been called again.
Open both dumps in WinDbg and start managed code debugging by invoking: .cordll -ve -u -l




















3.2. To identify threads either convert decimal Thread ids from Visual Studio to hexadecimal and look at OSID in output of: !threads
Or, as an alternative, look at stacks of all managed threads in WinDbg by invoking: !eestack -EE
After identifying the threads (first column in !threads output or "Thread N" in !eestack -EE output) a thread can be selected by invoking (N needs to be replaced by thread number - the N from "Thread N"): ~N s




















3.3. Select the same thread in both memory dumps and view managed stack (with parameters and local variables) by invoking: !clrstack -a
Examine local variables (LOCALS) for IsItemRelated(). The values (of value types) and heap addresses (for reference types) are on the right side of equal sign. 




















3.4. As no heap addresses (for the same thread) can be matched in both dumps (with high probability) it can be asumed that IsRelated() has returned and has been called again. This allows to conclude that threads are not stuck inside IsRelated() and the only problem is the infinite loop inside GetCompulationallyExpensiveCalculationResult().
As the algorithm used in this example is incomprehensible and makes no sense, there is no simple fix.
