1. Open the memory dump in Visual Studio. Use Parallel Stacks window to determine what code threads are executing.




















1.1. Two threads are inside GetCompulationallyExpensiveCalculationResult().




















2. Examine the method GetCompulationallyExpensiveCalculationResult() to determine why the threads are looping there. Select stack frame of this method and look at local variables.




















2.1. GetCompulationallyExpensiveCalculationResult() loops while value of local variable p is 10 or bigger, p is set to value of lookupTable element p (line "p = lookupTable[p];"). For both threads local variable p has value 98. lookupTable[98] has value 98, it means when p has a value 98 it never changes and code is stuck in infinite loop.




















3. Examine caller of GetCompulationallyExpensiveCalculationResult() - the method DoCalculationAndUpdateResultsInterlocked() to determine how it calls GetCompulationallyExpensiveCalculationResult(). Select stack frame of this method and look at local variables.




















3.1. DoCalculationAndUpdateResultsInterlocked() calls GetCompulationallyExpensiveCalculationResult() with parameter values 98 and 92. lookupTable[92] has value 98, it means that GetCompulationallyExpensiveCalculationResult(92) will enter the same infinite loop as GetCompulationallyExpensiveCalculationResult(98) after the first iteration.
As the algorithm used in this example is incomprehensible and makes no sense, there is no simple fix.
